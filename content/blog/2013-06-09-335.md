---
title: Go语言中处理抽象类的方法
date: '2013-06-09'
description:
categories:
- 技术
tags:
- go
---

在移植Java中的抽象类到Go的过程中遇到这样一个问题。原先的Java代码中，有一个继承自某个接口A的抽象类C，它包含自己的字段，也声明了一些保护方法供后代重载使用，同时还声明了一些公开方法，但并没有实现任何上级接口的方法。这个抽象类可以理解成为对上级接口的扩展，和读写接口有些类似。

Go语言中并没有对应的抽象类概念，但有两种可能的方法。
<ol>
	<li>使用嵌套接口。把该抽象类分解成一个新的接口B，以及一个抽象结构。抽象结构实现接口B的方法，但由于接口B嵌套了接口A，所以从理论上该抽象结构并不算是一个接口B的实现。子类则通过嵌套这个抽象结构的方式，获得其声明的保护方法，同时通过实现接口A的方法，以及用代理将接口B的方法重定向到该抽象结构中去。这样子类就同时可以看作是接口A和接口B的实现。</li>
	<li>直接嵌套抽象结构。Go语言中函数成了一等公民，可以通过声明一个新的结构，并把函数指针一起声明出来。如果给出实现的，则通过一个私有的方法将抽象结构附带的函数实现给出来。同时，还必须让该结构实现接口A的所有方法，当然实现可以是简单的panic提示。由于这个抽象结构不是接口，所以子类必须嵌套这个抽象结构。</li>
</ol>
最终的实现我选择了方案1。因为代码实现上更加清晰，避免了很多函数赋值，而且嵌套结构中的方法如果调用了子类继承的方法时，需要额外通过指针保证调用的正确性。换句话说，原先Java中很自然的多态性，都需要通过代码来一一指定，很麻烦，而且debug起来也很困难。
